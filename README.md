Задача 3. Очень умный неуказатель
========================


## Задача

Реализуйте шаблонный класс Spy, оборачивающий произвольный объект и логирующий обращения к нему.

Оборачиваемый объект необходимо хранить *по значению*. 2 года назад справедливо заметили, что называть такие сущности указателями неправильно, поэтому мы будем называть их умными неуказателями.

Если `s` &mdash; значение типа `Spy<T>`,  выражение `s->member` должно приводить к обращению к нестатическому члену `member` оборачиваемого объекта.

### Логеры

Метод `setLogger` устанавливает логер. После вычисления каждого выражения, содержащего обращения к оборачиваемому объекту через `operator ->`, должен вызываться логер, если он установлен. В качестве аргумента логер принимает количество обращений к объекту при вычислении выражения.

Обращения через `operator *` не логируются.

Если оборачиваемый тип `T` не копируемый, то `Spy<T>` должен поддерживать move-only логеры.

Если в одном выражении происходит обращение к оборачиваемому объекту и изменяется логер, поведение не определено.

Использовать `std::function` и `std::any` в этом задании запрещено.

### Сохранение концептов

Будем говорить, что умный неуказатель `W` сохраняет концепт `C`, если для любого типа `T`

1) `T` удовлетворяет `C` &rArr; `W<T>` удовлетворяет `C`,
2) `T` моделирует `C` &rArr; `W<T>` моделирует `C`.

Ваш `Spy` должен сохранять основные объектные концепты: `std::movable`, `std::copyable`, `std::semiregular`, `std::regular`. Для этого можно накладывать дополнительные ограничения на шаблонный аргумент метода `setLogger`.

Операторы сравнения должны сравнивать оборачиваемые объекты, игнорируя логер. При копировании (перемещении) должны копироваться (перемещаться) и логер, и оборачиваемый объект.

Если в одном выражении происходит обращение к оборачиваемому объекту и перемещение неуказателя, поведение не определено. Копирование создаёт новый объект, обращения к которому должны учитываться _отдельно_.


## Пример

```c++
struct Holder {
    int x = 0;
    bool isPositive() const {
        return x > 0;
    }
};

Spy s{Holder{}};
static_assert(std::semiregular<decltype(s)>);

s.setLogger([](auto n) { std::cout << n << std::endl; });

s->isPositive() && s->x--; // prints 1
s->x++ + s->x++; // prints 2
s->isPositive() && s->x--; // prints 2

s.setLogger([dummy = std::unique_ptr<int>()](auto n) {}); // compilation error

// -----------------------------------

struct MoveOnly {
    MoveOnly() = default;

    MoveOnly(MoveOnly&&) = default;
    MoveOnly& operator =(MoveOnly&&) = default;

    MoveOnly(const MoveOnly&) = delete;
    MoveOnly& operator =(const MoveOnly&) = delete;

    ~MoveOnly() noexcept = default;
};

Spy t{MoveOnly{}};

s.setLogger([dummy = std::unique_ptr<int>()](auto n) {}); // ok

static_assert(std::movable<decltype(t)>);
static_assert(!std::copyable<decltype(t)>);
```

