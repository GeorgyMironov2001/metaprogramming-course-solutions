Задача
Реализуйте шаблонный класс Spy, оборачивающий произвольный объект и логирующий обращения к нему.

Оборачиваемый объект необходимо хранить по значению. 2 года назад справедливо заметили, что называть такие сущности указателями неправильно, поэтому мы будем называть их умными неуказателями.

Если s — значение типа Spy<T>, выражение s->member должно приводить к обращению к нестатическому члену member оборачиваемого объекта.

Логеры
Метод setLogger устанавливает логер. После вычисления каждого выражения, содержащего обращения к оборачиваемому объекту через operator ->, должен вызываться логер, если он установлен. В качестве аргумента логер принимает количество обращений к объекту при вычислении выражения.

Обращения через operator * не логируются.

Если оборачиваемый тип T не копируемый, то Spy<T> должен поддерживать move-only логеры.

Если в одном выражении происходит обращение к оборачиваемому объекту и изменяется логер, поведение не определено.

Использовать std::function и std::any в этом задании запрещено.

Сохранение концептов
Будем говорить, что умный неуказатель W сохраняет концепт C, если для любого типа T

T удовлетворяет C ⇒ W<T> удовлетворяет C,
T моделирует C ⇒ W<T> моделирует C.
Ваш Spy должен сохранять основные объектные концепты: std::movable, std::copyable, std::semiregular, std::regular. Для этого можно накладывать дополнительные ограничения на шаблонный аргумент метода setLogger.

Операторы сравнения должны сравнивать оборачиваемые объекты, игнорируя логер. При копировании (перемещении) должны копироваться (перемещаться) и логер, и оборачиваемый объект.

Если в одном выражении происходит обращение к оборачиваемому объекту и перемещение неуказателя, поведение не определено. Копирование создаёт новый объект, обращения к которому должны учитываться отдельно.
